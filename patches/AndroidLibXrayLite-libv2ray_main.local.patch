diff --git a/libv2ray_main.go b/libv2ray_main.go
index 6dbfb68..6caf34a 100644
--- a/libv2ray_main.go
+++ b/libv2ray_main.go
@@ -33,6 +33,24 @@ const (
 	coreCert    = "xray.location.cert"
 	xudpBaseKey = "xray.xudp.basekey"
 	tunFdKey    = "xray.tun.fd"
+
+	// Real-delay test policy:
+	// - one measure call has 2 attempts (1 retry)
+	// - configurable attempt timeout (default 3 seconds)
+	delayTestAttempts          = 2
+	delayAttemptTimeoutDefault = 3 * time.Second
+	delayAttemptTimeoutMin     = 500 * time.Millisecond
+	delayAttemptTimeoutMax     = 30 * time.Second
+	delayOverallTimeout        = 20 * time.Second
+	delayFallbackTestURL       = "https://www.google.com/generate_204"
+	delaySeriesSamplesDefault  = 3
+	delaySeriesSamplesMin      = 1
+	delaySeriesSamplesMax      = 8
+)
+
+var (
+	delayAttemptTimeout     = delayAttemptTimeoutDefault
+	delayAttemptTimeoutLock sync.RWMutex
 )
 
 // CoreController represents a controller for managing Xray core instance lifecycle
@@ -153,10 +171,10 @@ func (x *CoreController) QueryStats(tag string, direct string) int64 {
 }
 
 // MeasureDelay measures network latency to a specified URL through the current core instance
-// Uses a 12-second timeout context and returns the round-trip time in milliseconds
+// Uses a bounded context and returns the round-trip time in milliseconds
 // An error is returned if the connection fails or returns an unexpected status
 func (x *CoreController) MeasureDelay(url string) (int64, error) {
-	ctx, cancel := context.WithTimeout(context.Background(), 12*time.Second)
+	ctx, cancel := context.WithTimeout(context.Background(), delayOverallTimeout)
 	defer cancel()
 
 	return measureInstDelay(ctx, x.coreInstance, url)
@@ -164,12 +182,100 @@ func (x *CoreController) MeasureDelay(url string) (int64, error) {
 
 // MeasureOutboundDelay measures the outbound delay for a given configuration and URL
 func MeasureOutboundDelay(ConfigureFileContent string, url string) (int64, error) {
-	config, err := coreserial.LoadJSONConfig(strings.NewReader(ConfigureFileContent))
+	inst, err := newDelayTestInstance(ConfigureFileContent)
 	if err != nil {
-		return -1, fmt.Errorf("config load error: %w", err)
+		return -1, err
+	}
+	defer inst.Close()
+
+	ctx, cancel := context.WithTimeout(context.Background(), delayOverallTimeout)
+	defer cancel()
+	return measureInstDelay(ctx, inst, url)
+}
+
+// MeasureOutboundDelaySeries measures multiple delay samples with one core startup.
+// Results are returned as a CSV string, for example: "120,132,-1".
+func MeasureOutboundDelaySeries(ConfigureFileContent string, url string, samples int64) string {
+	count := normalizeDelaySeriesSamples(samples)
+	results := make([]string, count)
+	for i := 0; i < count; i++ {
+		results[i] = "-1"
+	}
+
+	inst, err := newDelayTestInstance(ConfigureFileContent)
+	if err != nil {
+		return strings.Join(results, ",")
+	}
+	defer inst.Close()
+
+	// Protect the whole series with one upper-bound timeout.
+	totalTimeout := time.Duration(count*delayTestAttempts+1)*getDelayAttemptTimeout() + time.Second
+	if totalTimeout > delayOverallTimeout*2 {
+		totalTimeout = delayOverallTimeout * 2
+	}
+	ctx, cancel := context.WithTimeout(context.Background(), totalTimeout)
+	defer cancel()
+
+	for i := 0; i < count; i++ {
+		select {
+		case <-ctx.Done():
+			return strings.Join(results, ",")
+		default:
+		}
+		delayMs, err := measureInstDelay(ctx, inst, url)
+		if err == nil && delayMs >= 0 {
+			results[i] = strconv.FormatInt(delayMs, 10)
+		}
 	}
 
-	// Simplify config for testing
+	return strings.Join(results, ",")
+}
+
+// SetRealPingAttemptTimeoutMillis sets the attempt timeout used by outbound delay tests.
+func SetRealPingAttemptTimeoutMillis(timeoutMillis int64) {
+	timeout := time.Duration(timeoutMillis) * time.Millisecond
+	if timeout <= 0 {
+		timeout = delayAttemptTimeoutDefault
+	}
+	if timeout < delayAttemptTimeoutMin {
+		timeout = delayAttemptTimeoutMin
+	}
+	if timeout > delayAttemptTimeoutMax {
+		timeout = delayAttemptTimeoutMax
+	}
+
+	delayAttemptTimeoutLock.Lock()
+	delayAttemptTimeout = timeout
+	delayAttemptTimeoutLock.Unlock()
+}
+
+func getDelayAttemptTimeout() time.Duration {
+	delayAttemptTimeoutLock.RLock()
+	timeout := delayAttemptTimeout
+	delayAttemptTimeoutLock.RUnlock()
+	return timeout
+}
+
+func normalizeDelaySeriesSamples(samples int64) int {
+	if samples <= 0 {
+		return delaySeriesSamplesDefault
+	}
+	if samples < delaySeriesSamplesMin {
+		return delaySeriesSamplesMin
+	}
+	if samples > delaySeriesSamplesMax {
+		return delaySeriesSamplesMax
+	}
+	return int(samples)
+}
+
+func newDelayTestInstance(configContent string) (*core.Instance, error) {
+	config, err := coreserial.LoadJSONConfig(strings.NewReader(configContent))
+	if err != nil {
+		return nil, fmt.Errorf("config load error: %w", err)
+	}
+
+	// Keep only components needed for outbound delay checks.
 	config.Inbound = nil
 	var essentialApp []*serial.TypedMessage
 	for _, app := range config.App {
@@ -183,14 +289,15 @@ func MeasureOutboundDelay(ConfigureFileContent string, url string) (int64, error
 
 	inst, err := core.New(config)
 	if err != nil {
-		return -1, fmt.Errorf("instance creation failed: %w", err)
+		return nil, fmt.Errorf("instance creation failed: %w", err)
 	}
 
 	if err := inst.Start(); err != nil {
-		return -1, fmt.Errorf("startup failed: %w", err)
+		_ = inst.Close()
+		return nil, fmt.Errorf("startup failed: %w", err)
 	}
-	defer inst.Close()
-	return measureInstDelay(context.Background(), inst, url)
+
+	return inst, nil
 }
 
 // CheckVersionX returns the library and Xray versions
@@ -244,10 +351,13 @@ func measureInstDelay(ctx context.Context, inst *core.Instance, url string) (int
 	if inst == nil {
 		return -1, errors.New("core instance is nil")
 	}
+	attemptTimeout := getDelayAttemptTimeout()
 
 	tr := &http.Transport{
-		TLSHandshakeTimeout: 6 * time.Second,
-		DisableKeepAlives:   false,
+		TLSHandshakeTimeout:   attemptTimeout,
+		ResponseHeaderTimeout: attemptTimeout,
+		DisableKeepAlives:     true,
+		DisableCompression:    true,
 		DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
 			dest, err := corenet.ParseDestination(fmt.Sprintf("%s:%s", network, addr))
 			if err != nil {
@@ -256,75 +366,62 @@ func measureInstDelay(ctx context.Context, inst *core.Instance, url string) (int
 			return core.Dial(ctx, inst, dest)
 		},
 	}
+	defer tr.CloseIdleConnections()
 
 	client := &http.Client{
 		Transport: tr,
-		Timeout:   12 * time.Second,
+		Timeout:   attemptTimeout,
+		CheckRedirect: func(req *http.Request, via []*http.Request) error {
+			// Measure one request only; redirects would add unrelated latency.
+			return http.ErrUseLastResponse
+		},
 	}
 
 	if url == "" {
-		url = "https://www.google.com/generate_204"
+		url = delayFallbackTestURL
 	}
 
-	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
-	if err != nil {
-		return -1, fmt.Errorf("failed to create HTTP request: %w", err)
-	}
-
-	var minDuration int64 = -1
-	success := false
 	var lastErr error
 
-	// Add exception handling and increase retry attempts
-	const attempts = 2
-	for i := 0; i < attempts; i++ {
+	for attempt := 0; attempt < delayTestAttempts; attempt++ {
 		select {
 		case <-ctx.Done():
-			// Return immediately when context is canceled
-			if !success {
-				return -1, ctx.Err()
-			}
-			return minDuration, nil
+			return -1, ctx.Err()
 		default:
-			// Continue execution
+		}
+
+		attemptCtx, cancel := context.WithTimeout(ctx, attemptTimeout)
+		req, err := http.NewRequestWithContext(attemptCtx, "GET", url, nil)
+		if err != nil {
+			cancel()
+			return -1, fmt.Errorf("failed to create HTTP request: %w", err)
 		}
 
 		start := time.Now()
 		resp, err := client.Do(req)
 		if err != nil {
+			cancel()
 			lastErr = err
 			continue
 		}
 
-		// Ensure response body is closed
-		defer func(resp *http.Response) {
-			if resp != nil && resp.Body != nil {
-				resp.Body.Close()
-			}
-		}(resp)
+		statusCode := resp.StatusCode
+		_ = resp.Body.Close()
+		cancel()
 
-		if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusNoContent {
+		if statusCode != http.StatusOK && statusCode != http.StatusNoContent {
 			lastErr = fmt.Errorf("invalid status: %s", resp.Status)
 			continue
 		}
 
-		// Handle possible errors when reading response body
-		if _, err := io.Copy(io.Discard, resp.Body); err != nil {
-			lastErr = fmt.Errorf("failed to read response body: %w", err)
-			continue
-		}
-
-		duration := time.Since(start).Milliseconds()
-		if !success || duration < minDuration {
-			minDuration = duration
-		}
-
-		success = true
+		// Delay is measured to first response headers; body size should not affect latency.
+		return time.Since(start).Milliseconds(), nil
 	}
-	if !success {
-		return -1, lastErr
+
+	if lastErr == nil {
+		lastErr = errors.New("delay test failed")
 	}
-	return minDuration, nil
+	return -1, lastErr
 }
 
 // Log writer implementation
